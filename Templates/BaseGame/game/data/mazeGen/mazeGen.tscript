function mazeGen::onCreate(%this)
{
}

function mazeGen::onDestroy(%this)
{
}

//This is called when the server is initially set up by the game application
function mazeGen::initServer(%this)
{
}

//This is called when the server is created for an actual game/map to be played
function mazeGen::onCreateGameServer(%this)
{
    //These are common managed data files. For any datablock-based stuff that gets generated by the editors
    //(that doesn't have a specific associated file, like data for a player class) will go into these.
    //So we'll register them now if they exist.
    if(isFile("./scripts/managedData/managedDatablocks." @ $TorqueScriptFileExtension))
        %this.registerDatablock("./scripts/managedData/managedDatablocks");
    if(isFile("./scripts/managedData/managedForestItemData." @ $TorqueScriptFileExtension))
        %this.registerDatablock("./scripts/managedData/managedForestItemData");
    if(isFile("./scripts/managedData/managedForestBrushData." @ $TorqueScriptFileExtension))
        %this.registerDatablock("./scripts/managedData/managedForestBrushData");
    if(isFile("./scripts/managedData/managedParticleEmitterData." @ $TorqueScriptFileExtension))
        %this.registerDatablock("./scripts/managedData/managedParticleEmitterData");
    if(isFile("./scripts/managedData/managedParticleData." @ $TorqueScriptFileExtension))
        %this.registerDatablock("./scripts/managedData/managedParticleData");
}

//This is called when the server is shut down due to the game/map being exited
function mazeGen::onDestroyGameServer(%this)
{
}

//This is called when the client is initially set up by the game application
function mazeGen::initClient(%this)
{
}

//This is called when a client connects to a server
function mazeGen::onCreateClientConnection(%this)
{
}

//This is called when a client disconnects from a server
function mazeGen::onDestroyClientConnection(%this)
{
}

function getNextTileBounds(%rot,%scale)
{
    %rotatedScale = VectorRot(%scale,mDegToRad(%rot));
    %rotatedScale.x = mRound(mAbs(%rotatedScale.x));
    %rotatedScale.y = mRound(mAbs(%rotatedScale.y));
    %rotatedScale.z = mRound(mAbs(%rotatedScale.z));
    //%rotatedScale = VectorScale(%rotatedScale,0.5);
    //echo("in:("@%scale @"["@ %rot @"]) out:"@ %rotatedScale);
    return %rotatedScale;
}

function findGap(%startPos, %startRot, %scale)
{
    %nextBounds = getNextTileBounds(getWord(%startRot,3), %scale);
    %wallwidth = "1 1 1";
    %degRot = getRotationForwardVector(%startRot);
    %centroid = vectorAdd(%startPos,VectorMul(%degRot,vectorAdd(VectorScale(%nextBounds,0.5),%wallwidth)));
    %boxRad = VectorSub(VectorScale(%nextBounds,0.5), %wallwidth);
    //echo("centroid:"@ %centroid @"["@ getWord(%startRot,3) @"] area tested:"@ %boxRad );
    %isEmpty = containerBoxEmpty($TypeMasks::StaticObjectType,%centroid,%boxRad.x,%boxRad.y,%boxRad.z,false);
    if (%isEmpty)
    {
        expandMazebox(%centroid,VectorScale(%boxRad,2));
        createZoning(%startPos,%startRot,%centroid,VectorScale(%boxRad,2));
    }
    return %isEmpty;
}

function createZoning(%pos, %rot, %centroid, %box)
{
    $curPortal = new portal()
    { 
        position = %pos;
        scale = "30 3 30";
        rotation = %rot;
    };
    zoneGroup.add($curPortal);
    
    $curZone = new zone()
    { 
        position = %centroid;
        scale = %box;
    };
    zoneGroup.add($curZone);
}

function expandMazebox(%pos,%box)
{
    $mazeMax.x = getMaxF($mazeMax.x, %pos.x+%box.x);
    $mazeMax.y = getMaxF($mazeMax.y, %pos.y+%box.y);
    $mazeMax.z = getMaxF($mazeMax.z, %pos.z+%box.z);
    
    $mazeMin.x = getMinF($mazeMin.x, %pos.x-%box.x);
    $mazeMin.y = getMinF($mazeMin.y, %pos.y-%box.y);
    $mazeMin.z = getMinF($mazeMin.z, %pos.z-%box.z);    
}

function scrambleExits(%exits)
{
    %count = getWordCount(%exits);

    for (%i=%count-1;%i>0;%i--)
    {
        %swapTo = getrandom(%i);
        %original = getWord(%exits,%i);
        %altWord = getWord(%exits,%swapTo);
        %exits = setWord(%exits,%i,%altWord);
        %exits = setWord(%exits,%swapTo,%original);
    }
    //echo(%exits);
    return %exits;
}

function getRoomList()
{
    if (isObject(RoomList)) return;
    
    new arrayobject(RoomList);
    
    new arrayobject(corridorList);
        corridorList.bounds = "30 30 30";
        corridorList.add(0, "tileStraight");
        corridorList.add(1, "tileStraightNoWall");    
        corridorList.add(2, "tileLeft");
        corridorList.add(3, "tileRight");
        corridorList.add(4, "tileTJunction");
        corridorList.add(5, "tileXJunction");
    RoomList.add(0,corridorList);
    
    new arrayobject(stairList);
        stairList.bounds = "30 60 60";
        stairList.add(0, "tileUp");
        stairList.add(1, "tileDown");
    RoomList.add(1,stairList);
    
    new arrayobject(longList);
        longList.bounds = "30 150 30";
        longList.add(0, "tileLong");
        longList.add(1, "tileLongDoors");
    RoomList.add(2,longList);
    

    new arrayobject(medRoomist);
        medRoomist.bounds = "180 180 30";
        medRoomist.add(0, "tileCrossRoom");
    RoomList.add(3,medRoomist);
    
    new arrayobject(stackList);
        stackList.bounds = "180 180 100";
        stackList.add(0, "tileStackRoom");
    RoomList.add(5,stackList);
    
    new arrayobject(arenaList);
        arenaList.bounds = "300 300 100";
        arenaList.add(0, "tileArenaA");
        arenaList.add(1, "tileArenaB");
        arenaList.add(2, "tileArenaC");
    RoomList.add(5,arenaList);
}

function pickTile(%exitPos,%rot)
{
    //pick a tile from the potential list
    //bias for corridors
    %roomtype = 0;
    %completionPCT = $curTileCount/$mazeDepth;
    %nextEevntPCT = $eventRoomsSpawned/getMaxF($eventRooms,1);
    
    if (%completionPCT>%nextEevntPCT)
    {
        error("ratio: "@ %completionPCT SPC %nextEevntPCT);
        %roomtype = RoomList.count()-1;
    }
    else
    {
        if (getRandom(3) == 1)
            %roomtype = getRandom(RoomList.count()-2);
    }
    
    %tile = findRoomSize(%roomtype,%exitPos,%rot);
    return %tile;
}

function findRoomSize(%roomtype,%exitPos,%rot)
{
    // check if we have an empty gap for the tile, picking a smaller one to try if that fails
    if (%roomtype<0) return "";
    
    %roomTypeList = RoomList.getValue(%roomtype);
    if (!findGap(%exitPos, %rot, %roomTypeList.bounds))
        return findRoomSize(%roomtype-1,%exitPos,%rot);
    %tile = %roomTypeList.getValue(getRandom(%roomTypeList.count()-1));
    if (%roomtype == RoomList.count()-1)
    {
        $eventRoomsSpawned++;
    }
    return %tile;
}


function placeRoom(%nodeObj, %curExit, %count)
{
    %frameMesh = %nodeObj.getChildGroup()-->frame;
    //get where the next tile is to be placed, and in what orientation
    //do so by looking in the prefab for a tsstatic with internalname = "frame"; for a node labeled exit1-4
    %exitTrans = %frameMesh.getNodeTransform(%curExit);
    %exitPos = getWords(%exitTrans,0,2);             
    %rot  = getWords(%exitTrans,3,5) SPC mRound(mRadToDeg(getWord(%exitTrans,6)));
    
    %tile = pickTile(%exitPos,%rot); 
    
    if (%tile !$= "")
    {
        if (%count >1) //have we run out the clock on placeable tiles?
        {
            %mazNode = new Prefab()
            { 
                fileName = "data/mazeGen/prefabs/"@ %tile @".prefab";
                position = %exitPos;
                rotation = %rot;
            };
            getScene(0).add(%mazNode);
            placedTiles.push_back(%mazNode);
        }
        else
        {
            if (!isObject(mazeGoal)) //if we've hit max, go ahead and place our goal tile (assumes smallest size)
            {
                %mazNode = new Prefab(mazeGoal)
                { 
                    fileName = "data/mazeGen/prefabs/tileGoal.prefab";
                    position = %exitPos;
                    rotation = %rot;
                };
                getScene(0).add(%mazNode);
                placedTiles.push_back(%mazNode);
                RoomPlaced(%mazNode, %count);
            }
            else
            {
                %tile = "";
            }
        }
    }
    
    if (%tile $= "") //are we completely blocked?
    {
        %mazNode = new Prefab()
        { 
            fileName = "data/mazeGen/prefabs/tileWall.prefab";
            position = %exitPos;
            rotation = %rot;
        };
        getScene(0).add(%mazNode);
        placedTiles.push_back(%mazNode);
    }
    RoomPlaced(%mazNode, %count);
    if (%tile !$= "") return 1;
    return 0;
}

function RoomPlaced(%nodeObj, %count)
{
    %nodeObj.portal = $curPortal;
    %nodeObj.zone = $curZone;
    $scheduledExpansion--;
    %hasExit = true;
    
    if (%nodeObj.fileName $= "data/mazeGen/prefabs/tileWall.prefab")
        %hasExit = false;
    if (%nodeObj.fileName $= "data/mazeGen/prefabs/tileGoal.prefab")
        %hasExit = false;
        
    $curTileCount = getMaxF($curTileCount,$mazeDepth-%count);
    
    if ( %hasExit == true)
    {
        expandRooms(%nodeObj, %count);
    }
    if ($scheduledExpansion <=0)
    {
        cancel(mazeScheduler.finish);
        mazeScheduler.finish = schedule(32,mazeScheduler,"onMazeFilled");
    }
}

function expandRooms(%nodeObj, %count)
{
    if (!isObject(%nodeObj)) return;
    if (%count <=0) return;
    //warn("node depth remaing: ", %count);
    %frameMesh = %nodeObj.getChildGroup()-->frame;
    if (!isObject(%frameMesh))
    {
        echo("no frame detected in" @ %nodeObj.fileName);
        return;
    }
    %exitCount = 0;
    %exitList = "";

    while (%frameMesh.hasNode("exit"@ %exitCount+1))
    {
        %exitCount++;
        %exitList = %exitList SPC %exitCount;
    }
    %exitList = trim(%exitList);
    %exitList = scrambleExits(%exitList);
    %sucesses = 0;
    for (%i=0;%i<%exitCount;%i++)
    {
        $scheduledExpansion++;
        %curExit = "exit" @ getWord(%exitList,%i);
        %sucesses += placeRoom(%nodeObj, %curExit, %count-1);
    }
    %nodeObj.exitCount = %exitCount;
    
    %eraseCount = 1;
    if (%sucesses == 0 && %exitCount>1 && !isObject(mazeGoal))
    {
        placedTiles.moveLast();
        while (placedTiles.getCurrent() != 0)
        {
            placedTiles.movePrev();
            %objID = placedTiles.getKey(placedTiles.getCurrent());
            if (%objID.exitCount >1)
                break;
            %eraseCount++;
        }
        
        for (%i = 0;%i<=%eraseCount; %i++)
        {
            placedTiles.moveLast();
            %objID = placedTiles.getKey(placedTiles.getCurrent());
            if (isObject(%objID.portal)) %objID.portal.delete();
            if (isObject(%objID.zone)) %objID.zone.delete();
            %objID.delete();
            placedTiles.pop_back();
        }
        %objID = placedTiles.getKey(placedTiles.getCurrent());
        mazeScheduler.nextRun = schedule(320*%eraseCount,mazeScheduler,"expandRooms",%objID, %count+%eraseCount);
    }    
}

function onMazeFilled()
{
    if (isObject(mazeGoal))
    {
        if ($mazeGenFails>0)
            error("Failed Maze attempts:" @ $mazeGenFails);
        genNavmesh();
        $mazeGenFails=0;
        error("event rooms placed:" @$eventRoomsSpawned);
    }
    else
    {
        $mazeGenFails++;
        if ($mazeGenFails>$mazeDepth)
            mazeGen.FailMapLoad(false);
        else
            createMaze($mazeDepth,$eventRooms);
    }
}

function genNavmesh()
{
    if (!isObject(theNavMesh))
    {
        %newMesh = new NavMesh(theNavMesh)
        {
            position = "0 0 0";
            scale = "1 1 1";
        };
        getScene(0).add(%newMesh);
    }
    theNavMesh.position = vectorScale(VectorAdd($mazeMax,$mazeMin),0.5);
    theNavMesh.scale = vectorSub($mazeMax,$mazeMin);
    getScene(0).add(theNavMesh);
    theNavMesh.build();
    mazeGen.finishMapLoad();
}

function resetMaze()
{
    //reset global tracking vars
    $scheduledExpansion=0;
    $eventRoomsSpawned = 0;
    
    if (isObject(mazeScheduler))
    {
        mazeScheduler.delete();
    }        
    new scriptObject(mazeScheduler){};
    if (isObject(zoneGroup))
    {
        zoneGroup.delete();
    }
    new simGroup(zoneGroup){};
    getScene(0).add(zoneGroup);
    if (!isObject(placedTiles))
    {
        new ArrayObject(placedTiles){};
    }
    else
    {
        placedTiles.moveLast();
        while (placedTiles.count()>0)
        {
            %objID = placedTiles.getKey(placedTiles.getCurrent());
            %objID.delete();
            placedTiles.pop_back();
        }
    }
    
    $mazeMax = "1 1 1";
    $mazeMin = "-1 -1 -1";
    if (isObject(theNavMesh))
        theNavMesh.cancelBuild();
}

function mazeGen::finishMapLoad(%this)
{
    Core_ClientServer.finishMapLoad();
    echo("Maze Ready");
}

function mazeGen::FailMapLoad(%this,%isFine)
{
    Core_ClientServer.FailMapLoad("mazeGen", true);
}

function mazeGen::onLoadMap(%this)
{
    createMaze(3,1);
}

function createMaze(%tileDepth, %poi)
{
    getRoomList();
    $mazeDepth = %tileDepth;
    $eventRooms = %poi;
    if (%tileDepth == 0) %tileDepth =50;
    resetMaze();
    %mazeStart = new Prefab(mazeStart) {
        fileName = "data/mazeGen/prefabs/tileStart.prefab";
    };
    placedTiles.push_back(%mazeStart);
    getScene(0).add(%mazeStart);
    expandRooms(%mazeStart, %tileDepth*(%poi+1));
}