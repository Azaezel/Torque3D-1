function Prototyping::onCreate(%this)
{
}

function Prototyping::onDestroy(%this)
{
}

//This is called when the server is initially set up by the game application
function Prototyping::initServer(%this)
{
}

//This is called when the server is created for an actual game/map to be played
function Prototyping::onCreateGameServer(%this)
{
    //These are common managed data files. For any datablock-based stuff that gets generated by the editors
    //(that doesn't have a specific associated file, like data for a player class) will go into these.
    //So we'll register them now if they exist.
    if(isFile("./scripts/managedData/managedDatablocks." @ $TorqueScriptFileExtension))
        %this.registerDatablock("./scripts/managedData/managedDatablocks");
    if(isFile("./scripts/managedData/managedForestItemData." @ $TorqueScriptFileExtension))
        %this.registerDatablock("./scripts/managedData/managedForestItemData");
    if(isFile("./scripts/managedData/managedForestBrushData." @ $TorqueScriptFileExtension))
        %this.registerDatablock("./scripts/managedData/managedForestBrushData");
    if(isFile("./scripts/managedData/managedParticleEmitterData." @ $TorqueScriptFileExtension))
        %this.registerDatablock("./scripts/managedData/managedParticleEmitterData");
    if(isFile("./scripts/managedData/managedParticleData." @ $TorqueScriptFileExtension))
        %this.registerDatablock("./scripts/managedData/managedParticleData");
}

//This is called when the server is shut down due to the game/map being exited
function Prototyping::onDestroyGameServer(%this)
{
}

//This is called when the client is initially set up by the game application
function Prototyping::initClient(%this)
{
}

//This is called when a client connects to a server
function Prototyping::onCreateClientConnection(%this)
{
}

//This is called when a client disconnects from a server
function Prototyping::onDestroyClientConnection(%this)
{
}

function getNextTileBounds(%rot,%scale)
{
    %rotatedScale = VectorRot(%scale,%rot);
    %rotatedScale.x = mRound(mAbs(%rotatedScale.x));
    %rotatedScale.y = mRound(mAbs(%rotatedScale.y));
    %rotatedScale.z = mRound(mAbs(%rotatedScale.z));
    //echo(%rotatedScale);
    %rotatedScale = VectorScale(%rotatedScale,0.5);
    return %rotatedScale;
}

function findGap(%startPos, %startRot, %scale)
{
    %wallwidth = "0.1 0.1 0.1";
    %nextBounds = getNextTileBounds(getWord(%startRot,3), %scale);
    //warn("exit"@ %i @" found:("@ %startPos @")("@ %nextBounds @")");
    %degRot = getRotationForwardVector(%startRot);
    %boxRad = VectorSub(%nextBounds, %wallwidth);
    %newPos = vectorAdd(%startPos,VectorScale(%degRot,VectorLen(%nextBounds)));
    //echo("startPos:"@ %newPos @" nextBounds:"@ %nextBounds @" scale:"@ %boxRad );
    return containerBoxEmpty($TypeMasks::StaticObjectType,%newPos,%boxRad.x,%boxRad.y,%boxRad.z,false); 
}

function expandRooms(%nodeObj, %count)
{
    if (!isObject(%nodeObj)) return;
    if (%count <=0) return;
    //warn("node depth remaing: ", %count);
    %frameMesh = %nodeObj.getChildGroup()-->frame;
    for (%i=1;%i<4;%i++)
    {
        if (%frameMesh.hasNode("exit"@ %i))
        {
            //get where the next tile is to be placed, and in what orientation
            //do so by looking in the prefab for a tsstatic with internalname = "frame"; for a node labeled exit1-4
            %exitTrans = %frameMesh.getNodeTransform("exit"@ %i);
            %exitPos = getWords(%exitTrans,0,2);             
		    %rot  = getWords(%exitTrans,3,5) SPC mRound(mRadToDeg(getWord(%exitTrans,6)));
            
            //pick a tile from the potential list
            %tilenum = getrandom(7)+1;
            
            // check if we have an empty gap for the tile, picking a smaller one to try if that fails
            // todo: better size-tracking logic
            %okay = false;
            if (%tilenum>6) //magic numbers are magic. fix meh.
            {
                %okay = findGap(%exitPos, %rot, "4 4 8");
                if (!%okay) %tilenum -=6;
            }
            if (!%okay)
                %okay = findGap(%exitPos, %rot, "2 2 2");
                
            if (%okay)
            {
                if (%count >1) //have we run out the clock on placeable tiles?
                {
                    %count--;
                    %mazNode = new Prefab()
                    { 
                        fileName = "data/Prototyping/prefabs/tile"@ %tilenum @".prefab";
                        position = %exitPos;
                        rotation = %rot;
                    };
                    getScene(0).add(%mazNode);
                    if (!expandRooms(%mazNode, %count))
                        %count++;
                }
                else
                {
                    %okay = false;
                    if ($goalPlaced == false) //if we've hit max, go ahead and place our goal tile (assumes smallest size)
                    {
                        %mazNode = new Prefab(goal)
                        { 
                            fileName = "data/Prototyping/prefabs/tileGoal.prefab";
                            position = %exitPos;
                            rotation = %rot;
                        };
                        getScene(0).add(%mazNode);
                        $goalPlaced = true;
                        %count++;
                        return false; //early out so we don't wall ourselves off
                    }
                }
                    
             }
             else
             { 
                //warn(%frameMesh.shapeAsset @".exit"@ %i @" blocked at ("@ %exitPos @")+("@ %offset @")=("@ %newPos @")");
                %okay = false;
             }
             if (%okay == false) //are we completely blocked?
             {
                %mazNode = new Prefab()
                { 
                    fileName = "data/Prototyping/prefabs/tileBlock.prefab";
                    position = %exitPos;
                    rotation = %rot;
                };
                getScene(0).add(%mazNode);
             }
        }
    }
    return %okay;
}

function createMaze()
{
   $goalPlaced = false;
   %mazeStart = new Prefab(start) {
      fileName = "data/Prototyping/prefabs/tileStart.prefab";
   };
   getScene(0).add(%mazeStart);
   expandRooms(%mazeStart, 20);
   if ($goalPlaced == false) //todo: track tiles in an array, and kill em to regen it if all else fails
    error("bad maze!");
}