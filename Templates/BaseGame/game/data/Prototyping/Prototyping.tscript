function Prototyping::onCreate(%this)
{
}

function Prototyping::onDestroy(%this)
{
}

//This is called when the server is initially set up by the game application
function Prototyping::initServer(%this)
{
}

//This is called when the server is created for an actual game/map to be played
function Prototyping::onCreateGameServer(%this)
{
    //These are common managed data files. For any datablock-based stuff that gets generated by the editors
    //(that doesn't have a specific associated file, like data for a player class) will go into these.
    //So we'll register them now if they exist.
    if(isFile("./scripts/managedData/managedDatablocks." @ $TorqueScriptFileExtension))
        %this.registerDatablock("./scripts/managedData/managedDatablocks");
    if(isFile("./scripts/managedData/managedForestItemData." @ $TorqueScriptFileExtension))
        %this.registerDatablock("./scripts/managedData/managedForestItemData");
    if(isFile("./scripts/managedData/managedForestBrushData." @ $TorqueScriptFileExtension))
        %this.registerDatablock("./scripts/managedData/managedForestBrushData");
    if(isFile("./scripts/managedData/managedParticleEmitterData." @ $TorqueScriptFileExtension))
        %this.registerDatablock("./scripts/managedData/managedParticleEmitterData");
    if(isFile("./scripts/managedData/managedParticleData." @ $TorqueScriptFileExtension))
        %this.registerDatablock("./scripts/managedData/managedParticleData");
}

//This is called when the server is shut down due to the game/map being exited
function Prototyping::onDestroyGameServer(%this)
{
}

//This is called when the client is initially set up by the game application
function Prototyping::initClient(%this)
{
}

//This is called when a client connects to a server
function Prototyping::onCreateClientConnection(%this)
{
}

//This is called when a client disconnects from a server
function Prototyping::onDestroyClientConnection(%this)
{
}

function getNextTileBounds(%rot,%scale)
{
    %rotatedScale = VectorRot(%scale,mDegToRad(%rot));
    %rotatedScale.x = mRound(mAbs(%rotatedScale.x));
    %rotatedScale.y = mRound(mAbs(%rotatedScale.y));
    %rotatedScale.z = mRound(mAbs(%rotatedScale.z));
    %rotatedScale = VectorScale(%rotatedScale,0.5);
    //echo("in:("@%scale @"["@ %rot @"]) out:"@ %rotatedScale);
    return %rotatedScale;
}

function vectorLongest(%vec)
{
    return getMaxF(getMaxF(%vec.x,%vec.y),%vec.z);
}

function findGap(%startPos, %startRot, %scale)
{
    %nextBounds = getNextTileBounds(getWord(%startRot,3), %scale);
    %wallwidth = "0.001 0.001 0.001";
    %degRot = getRotationForwardVector(%startRot);
    %newPos = vectorAdd(%startPos,VectorScale(%degRot,vectorLongest(%nextBounds)));
    %boxRad = VectorSub(%nextBounds, %wallwidth);
    //echo("centroid:"@ %newPos @"["@ getWord(%startRot,3) @"] area tested:"@ %boxRad );
    %isEmpty = containerBoxEmpty($TypeMasks::StaticObjectType,%newPos,%boxRad.x,%boxRad.y,%boxRad.z,false);
    if (%isEmpty)
        expandMazebox(%newPos,%nextBounds);
    return %isEmpty;
}

function expandMazebox(%pos,%box)
{
    $mazeMax.x = getMaxF($mazeMax.x, %pos.x+%box.x);
    $mazeMax.y = getMaxF($mazeMax.y, %pos.y+%box.y);
    $mazeMax.z = getMaxF($mazeMax.z, %pos.z+%box.z);
    
    $mazeMin.x = getMinF($mazeMin.x, %pos.x-%box.x);
    $mazeMin.y = getMinF($mazeMin.y, %pos.y-%box.y);
    $mazeMin.z = getMinF($mazeMin.z, %pos.z-%box.z);
}

function scrambleExits(%exits)
{
    %count = getWordCount(%exits);

    for (%i=%count-1;%i>0;%i--)
    {
        %swapTo = getrandom(%i);
        %original = getWord(%exits,%i);
        %altWord = getWord(%exits,%swapTo);
        %exits = setWord(%exits,%i,%altWord);
        %exits = setWord(%exits,%swapTo,%original);
    }
    //echo(%exits);
    return %exits;
}

function findRoomSize(%tilenum,%exitPos,%rot)
{
    // check if we have an empty gap for the tile, picking a smaller one to try if that fails
    // todo: better size-tracking logic
    %okay = false;
    if (%tilenum == 9) //magic numbers are magic. fix meh.
    {
        if (!findGap(%exitPos, %rot, "20 20 5"))
        {
            %tilenum -=1;
            return findRoomSize(%tilenum,%exitPos,%rot);
        }
    }
    else if (%tilenum == 8) //magic numbers are magic. fix meh.
    {
        if (!findGap(%exitPos, %rot, "10 10 20"))
        {
            %tilenum -=1;
            return findRoomSize(%tilenum,%exitPos,%rot);
        }
    }
    else if (%tilenum>5) //magic numbers are magic. fix meh.
    {
        if (!findGap(%exitPos, %rot, "5 10 20"))
        {
            %tilenum -=2;
            return findRoomSize(%tilenum,%exitPos,%rot);
        }
    }
    else if (!findGap(%exitPos, %rot, "5 5 5"))
    {
        %tilenum = 0;
        //echo("fully blocked!");
    }
    return %tilenum;
}

function placeRoom(%nodeObj, %curExit, %count)
{
    %frameMesh = %nodeObj.getChildGroup()-->frame;
    //get where the next tile is to be placed, and in what orientation
    //do so by looking in the prefab for a tsstatic with internalname = "frame"; for a node labeled exit1-4
    %exitTrans = %frameMesh.getNodeTransform(%curExit);
    %exitPos = getWords(%exitTrans,0,2);             
    %rot  = getWords(%exitTrans,3,5) SPC mRound(mRadToDeg(getWord(%exitTrans,6)));
    
    //pick a tile from the potential list
    %tilenum = getrandom(8)+1;
    %tilenum = findRoomSize(%tilenum,%exitPos,%rot);
    
    if (%tilenum>0)
    {
        if (%count >1) //have we run out the clock on placeable tiles?
        {
            %mazNode = new Prefab()
            { 
                fileName = "data/Prototyping/prefabs/tile"@ %tilenum @".prefab";
                position = %exitPos;
                rotation = %rot;
            };
            getScene(0).add(%mazNode);
            placedTiles.push_back(%mazNode);
        }
        else
        {
            if ($goalPlaced == false) //if we've hit max, go ahead and place our goal tile (assumes smallest size)
            {
                %mazNode = new Prefab(mazeGoal)
                { 
                    fileName = "data/Prototyping/prefabs/tileGoal.prefab";
                    position = %exitPos;
                    rotation = %rot;
                };
                getScene(0).add(%mazNode);
                placedTiles.push_back(%mazNode);
                $goalPlaced = true;
                RoomPlaced(%mazNode, %count);
            }
            else
            {
                %tilenum = 0;
            }
        }
    }
    
    if (%tilenum == 0) //are we completely blocked?
    {
        %mazNode = new Prefab()
        { 
            fileName = "data/Prototyping/prefabs/tileBlock.prefab";
            position = %exitPos;
            rotation = %rot;
        };
        getScene(0).add(%mazNode);
        placedTiles.push_back(%mazNode);
    }
    RoomPlaced(%mazNode, %count);
}

function RoomPlaced(%nodeObj, %count)
{
    $scheduledExpansion--;
    %noExit = false;
    
    if (%nodeObj.fileName $= "data/Prototyping/prefabs/tileBlock.prefab")
        %noExit = false;
    if (%nodeObj.fileName $= "data/Prototyping/prefabs/tileGoal.prefab")
        %noExit = false;

    if ( %noExit == false)
    {
        expandRooms(%nodeObj, %count-1);
    }
}

function expandRooms(%nodeObj, %count)
{
    if (!isObject(%nodeObj)) return;
    if (%count <=0) return;
    //warn("node depth remaing: ", %count);
    %frameMesh = %nodeObj.getChildGroup()-->frame;
    if (!isObject(%frameMesh))
    {
        echo("no frame detected in" @ %nodeObj.fileName);
        return;
    }
    %exitCount = 0;
    %exitList = "";

    while (%frameMesh.hasNode("exit"@ %exitCount+1))
    {
        %exitCount++;
        %exitList = %exitList SPC %exitCount;
    }
    %exitList = trim(%exitList);
    %exitList = scrambleExits(%exitList);
    
    for (%i=0;%i<%exitCount;%i++)
    {
        $scheduledExpansion++;
        %curExit = "exit" @ getWord(%exitList,%i);
        //need to give things time to spawn to test against
        mazeScheduler.nextTimeSlot += %i;
        schedule(mazeScheduler.nextTimeSlot,mazeScheduler,"placeRoom", %nodeObj, %curExit, %count);
    }
    if ($scheduledExpansion <=0)
        onMazeFilled();
}

function onMazeFilled()
{
    if ($goalPlaced)
        genNavmesh();
    else
        createMaze($mazeDepth);
}

function genNavmesh()
{
    if (!isObject(theNavMesh))
    {
        %newMesh = new NavMesh(theNavMesh)
        {
        };
        getScene(0).add(%newMesh);
    }
    theNavMesh.position = vectorScale(VectorAdd($mazeMax,$mazeMin),0.5);
    theNavMesh.scale = vectorSub($mazeMax,$mazeMin);
    theNavMesh.build();
    onMazeDone();
}

function resetMaze()
{
    //reset global tracking vars
    $goalPlaced = false;
    $scheduledExpansion=0;
    
    if (isObject(mazeScheduler))
    {
        mazeScheduler.delete();
    }        
    new scriptObject(mazeScheduler){};
    
    if (!isObject(placedTiles))
    {
        new ArrayObject(placedTiles){};
    }
    else
    {
        placedTiles.setCurrent(placedTiles.count()-1);
        while (placedTiles.count()>0)
        {
            %objID = placedTiles.getKey(placedTiles.getCurrent());
            %objID.delete();
            placedTiles.pop_back();
        }
    }
    
    $mazeMax = "1 1 1";
    $mazeMin = "-1 -1 -1";
    if (isObject(theNavMesh))
        theNavMesh.cancelBuild();
}

function onMazeDone()
{
    echo("Maze Ready");
}

//createMaze(10)
function createMaze(%tileDepth)
{
    $mazeDepth = %tileDepth;
    if (%tileDepth == 0) %tileDepth =50;
    resetMaze();
    %mazeStart = new Prefab(mazeStart) {
        fileName = "data/Prototyping/prefabs/tileStart.prefab";
    };
    placedTiles.push_back(%mazeStart);
    getScene(0).add(%mazeStart);
    expandRooms(%mazeStart, %tileDepth);
}