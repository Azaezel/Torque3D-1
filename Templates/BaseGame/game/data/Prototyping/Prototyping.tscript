function Prototyping::onCreate(%this)
{
}

function Prototyping::onDestroy(%this)
{
}

//This is called when the server is initially set up by the game application
function Prototyping::initServer(%this)
{
}

//This is called when the server is created for an actual game/map to be played
function Prototyping::onCreateGameServer(%this)
{
    //These are common managed data files. For any datablock-based stuff that gets generated by the editors
    //(that doesn't have a specific associated file, like data for a player class) will go into these.
    //So we'll register them now if they exist.
    if(isFile("./scripts/managedData/managedDatablocks." @ $TorqueScriptFileExtension))
        %this.registerDatablock("./scripts/managedData/managedDatablocks");
    if(isFile("./scripts/managedData/managedForestItemData." @ $TorqueScriptFileExtension))
        %this.registerDatablock("./scripts/managedData/managedForestItemData");
    if(isFile("./scripts/managedData/managedForestBrushData." @ $TorqueScriptFileExtension))
        %this.registerDatablock("./scripts/managedData/managedForestBrushData");
    if(isFile("./scripts/managedData/managedParticleEmitterData." @ $TorqueScriptFileExtension))
        %this.registerDatablock("./scripts/managedData/managedParticleEmitterData");
    if(isFile("./scripts/managedData/managedParticleData." @ $TorqueScriptFileExtension))
        %this.registerDatablock("./scripts/managedData/managedParticleData");
}

//This is called when the server is shut down due to the game/map being exited
function Prototyping::onDestroyGameServer(%this)
{
}

//This is called when the client is initially set up by the game application
function Prototyping::initClient(%this)
{
}

//This is called when a client connects to a server
function Prototyping::onCreateClientConnection(%this)
{
}

//This is called when a client disconnects from a server
function Prototyping::onDestroyClientConnection(%this)
{
}

function getNextTileBounds(%rot,%scale)
{
    %rotatedScale = VectorRot(%scale,%rot);
    %rotatedScale.x = mRound(mAbs(%rotatedScale.x));
    %rotatedScale.y = mRound(mAbs(%rotatedScale.y));
    %rotatedScale.z = mRound(mAbs(%rotatedScale.z));
    //echo(%rotatedScale);
    //%rotatedScale = VectorScale(%rotatedScale,0.5);
    return %rotatedScale;
}

function findGap(%startPos, %startRot, %scale)
{
    %scale = vectorAdd(%scale, "1 1 1");
    %wallwidth = "0.0 0.0 0.0";
    %nextBounds = getNextTileBounds(getWord(%startRot,3), %scale);
    //warn("exit"@ %i @" found:("@ %startPos @")("@ %nextBounds @")");
    %degRot = getRotationForwardVector(%startRot);
    %boxRad = VectorSub(%nextBounds, %wallwidth);
    %newPos = vectorAdd(%startPos,VectorScale(%degRot,VectorLen(%nextBounds)));
    //echo("startPos:"@ %newPos @" nextBounds:"@ %nextBounds @" scale:"@ %boxRad );
    %isEmpty = containerBoxEmpty($TypeMasks::StaticObjectType,%newPos,%boxRad.x,%boxRad.y,%boxRad.z,false); 
    if (%isEmpty)
        expandMazebox(%newPos,%boxRad);
    return %isEmpty;
}

function expandMazebox(%pos,%box)
{
    $mazeMax.x = getMaxF($mazeMax.x, %pos.x+%box.x);
    $mazeMax.y = getMaxF($mazeMax.y, %pos.y+%box.y);
    $mazeMax.z = getMaxF($mazeMax.z, %pos.z+%box.z);
    
    $mazeMin.x = getMinF($mazeMin.x, %pos.x-%box.x);
    $mazeMin.y = getMinF($mazeMin.y, %pos.y-%box.y);
    $mazeMin.z = getMinF($mazeMin.z, %pos.z-%box.z);
}

function scrambleExits(%exits)
{
    %count = getWordCount(%exits);

    for (%i=%count-1;%i>0;%i--)
    {
        %swapTo = getrandom(%i);
        %original = getWord(%exits,%i);
        %altWord = getWord(%exits,%swapTo);
        %exits = setWord(%exits,%i,%altWord);
        %exits = setWord(%exits,%swapTo,%original);
    }
    //echo(%exits);
    return %exits;
}

function expandRooms(%nodeObj, %count)
{
    if (!isObject(%nodeObj)) return;
    if (%count <=0) return;
    //warn("node depth remaing: ", %count);
    %frameMesh = %nodeObj.getChildGroup()-->frame;
    
    %exitCount = 0;
    %exitList = "";
    for (%i=0;%i<4;%i++)
    {
        if (%frameMesh.hasNode("exit"@ %i))
        {
            %exitCount++;
            %exitList = %exitList SPC %exitCount;
        }
    }
    %exitList = trim(%exitList);
    %exitList = scrambleExits(%exitList);
    
    for (%i=0;%i<%exitCount;%i++)
    {
        %curExit = "exit" @ getWord(%exitList,%i);
        //get where the next tile is to be placed, and in what orientation
        //do so by looking in the prefab for a tsstatic with internalname = "frame"; for a node labeled exit1-4
        %exitTrans = %frameMesh.getNodeTransform(%curExit);
        %exitPos = getWords(%exitTrans,0,2);             
        %rot  = getWords(%exitTrans,3,5) SPC mRound(mRadToDeg(getWord(%exitTrans,6)));
            
        //pick a tile from the potential list
        %tilenum = getrandom(8)+1;
            
        // check if we have an empty gap for the tile, picking a smaller one to try if that fails
        // todo: better size-tracking logic
        %okay = false;
        if (%tilenum>8) //magic numbers are magic. fix meh.
        {
            %okay = findGap(%exitPos, %rot, "20 20 5");
            if (!%okay) %tilenum -=1;
        }
        if (%tilenum>6) //magic numbers are magic. fix meh.
        {
            %okay = findGap(%exitPos, %rot, "10 10 10");
            if (!%okay) %tilenum -=6;
        }
        if (!%okay)
            %okay = findGap(%exitPos, %rot, "5 5 5");
                
        if (%okay)
        {
            if (%count >1) //have we run out the clock on placeable tiles?
            {
                %count--;
                %mazNode[%i] = new Prefab()
                { 
                    fileName = "data/Prototyping/prefabs/tile"@ %tilenum @".prefab";
                    position = %exitPos;
                    rotation = %rot;
                };
                getScene(0).add(%mazNode[%i]);
                placedTiles.push_back(%mazNode[%i]);
            }
            else
            {
                %okay = false;
                if ($goalPlaced == false) //if we've hit max, go ahead and place our goal tile (assumes smallest size)
                {
                    %mazNode[%i] = new Prefab(mazeGoal)
                    { 
                        fileName = "data/Prototyping/prefabs/tileGoal.prefab";
                        position = %exitPos;
                        rotation = %rot;
                    };
                    getScene(0).add(%mazNode[%i]);
                    placedTiles.push_back(%mazNode[%i]);
                    $goalPlaced = true;
                    %count++;
                    continue; //early out so we don't wall ourselves off
                }
            }
        }
        else
        {
            %okay = false;
        }
        if (%okay == false) //are we completely blocked?
        {
            %mazNode[%i] = new Prefab()
            { 
                fileName = "data/Prototyping/prefabs/tileBlock.prefab";
                position = %exitPos;
                rotation = %rot;
            };
            getScene(0).add(%mazNode[%i]);
            placedTiles.push_back(%mazNode[%i]);
        }
    }
    $scheduledExpansion--;
    for (%i=0;%i<%exitCount;%i++)
    {
        if (%mazNode[%i].fileName !$= "data/Prototyping/prefabs/tileBlock.prefab")
        {
            $scheduledExpansion++;
            schedule(32,0,"expandRooms",%mazNode[%i], %count);
        }
    }
    if ($scheduledExpansion <=0)
        onMazeDone();
}

function genNavmesh()
{
	%newMesh = new NavMesh(theNavMesh)
	{
        position = vectorScale(VectorAdd($mazeMax,$mazeMin),0.5);
        scale = vectorSub($mazeMax,$mazeMin);
	};
	getScene(0).add(%newMesh);
    %newMesh.build();
}

function resetMaze()
{
    //reset global tracking vars
    $goalPlaced = false;
    if (!isObject(placedTiles))
    {
        new ArrayObject(placedTiles){};
    }
    else
    {
        placedTiles.setCurrent(placedTiles.count()-1);
        while (placedTiles.count()>0)
        {
            %objID = placedTiles.getKey(placedTiles.getCurrent());
            %objID.delete();
            placedTiles.pop_back();
        }
    }
    
    $mazeMax = "1 1 1";
    $mazeMin = "-1 -1 -1";
    if (isObject(theNavMesh))
        theNavMesh.cancelBuild();
}

function onMazeDone()
{
    if ($goalPlaced)
        genNavmesh();
    else
        createMaze();
}

function createMaze()
{
    resetMaze();        
    $scheduledExpansion=1;
    %mazeStart = new Prefab(mazeStart) {
        fileName = "data/Prototyping/prefabs/tileStart.prefab";
    };
    placedTiles.push_back(%mazeStart);
    getScene(0).add(%mazeStart);
    expandRooms(%mazeStart, 50);
}