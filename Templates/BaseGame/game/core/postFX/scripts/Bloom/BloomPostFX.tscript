//-----------------------------------------------------------------------------
// Copyright (c) 2012 GarageGames, LLC
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
//-----------------------------------------------------------------------------

// Inspired by bloom described in paper listed here:
// http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare

$PostFX::BloomPostFX::threshold = 0.75;
$PostFX::BloomPostFX::intensity = 1.0;
$PostFX::BloomPostFX::radius = 4.0;

$PostFX::BloomPostFX::dirtEnabled = true;
$PostFX::BloomPostFX::dirtScale = 2048.0;
$PostFX::BloomPostFX::dirtIntensity = 2.0;
$PostFX::BloomPostFX::dirtEdgeMinDist = 0.125;
$PostFX::BloomPostFX::dirtEdgeMaxDist = 0.75;
$PostFX::BloomPostFX::dirtEdgeMinVal = 0.05;
$PostFX::BloomPostFX::dirtImage = "core/postFX/images/lensDirt.png";

singleton ShaderData( Bloom_ThresholdShader )
{
   DXVertexShaderFile = $Core::CommonShaderPath @ "/postFX/postFxV.hlsl";
   DXPixelShaderFile  = "./bloomThresholdP.hlsl";
   OGLVertexShaderFile= $Core::CommonShaderPath @ "/postFX/gl/postFxV.glsl";
   OGLPixelShaderFile = "./gl/bloomThresholdP.glsl";
   
   samplerNames[0] = "$inputTex";
   
   pixVersion = 3.0;
};

singleton ShaderData( Bloom_DownSampleShader )
{
   DXVertexShaderFile = $Core::CommonShaderPath @ "/postFX/postFxV.hlsl";
   DXPixelShaderFile  = "./downSampleP.hlsl";
   OGLVertexShaderFile= $Core::CommonShaderPath @ "/postFX/gl/postFxV.glsl";
   OGLPixelShaderFile = "./gl/downSampleP.glsl";
   
   samplerNames[0] = "$inputTex";
   
   pixVersion = 3.0;
};

singleton ShaderData( Bloom_UpSampleShader )
{
   DXVertexShaderFile = $Core::CommonShaderPath @ "/postFX/postFxV.hlsl";
   DXPixelShaderFile  = "./upSampleP.hlsl";
   OGLVertexShaderFile= $Core::CommonShaderPath @ "/postFX/gl/postFxV.glsl";
   OGLPixelShaderFile = "./gl/upSampleP.glsl";
   
   samplerNames[0] = "$nxtTex";
   samplerNames[1] = "$mipTex";
   
   pixVersion = 3.0;
};

singleton ShaderData( Bloom_StrengthShader )
{
   DXVertexShaderFile = $Core::CommonShaderPath @ "/postFX/postFxV.hlsl";
   DXPixelShaderFile  = "./bloomStrengthP.hlsl";
   OGLVertexShaderFile= $Core::CommonShaderPath @ "/postFX/gl/postFxV.glsl";
   OGLPixelShaderFile = "./gl/bloomStrengthP.glsl";
   
   samplerNames[0] = "$inputTex";
   samplerNames[1] = "$dirtTex";
   
   pixVersion = 3.0;
};

singleton GFXStateBlockData( Bloom_SampleStateBlock : PFX_DefaultStateBlock )
{
   samplersDefined = true;
   samplerStates[0] = SamplerClampLinear;
   samplerStates[1] = SamplerClampLinear;
};

singleton GFXStateBlockData( Bloom_Add_SampleStateBlock : PFX_DefaultStateBlock )
{ 
   // Do a one to one blend.
   blendDefined = true;
   blendEnable = true;
   blendSrc = GFXBlendOne;
   blendDest = GFXBlendOne;

   samplersDefined = true;
   samplerStates[0] = SamplerClampLinear;
   samplerStates[1] = SamplerWrapLinear;
};

function BloomPostFX::setShaderConsts( %this )
{
   %this.setShaderConst("$threshold", $PostFX::BloomPostFX::threshold);
   
   %blur = %this->bloomBlur;
   for (%idx = 0; %idx < %this.mipsCount; %idx++)
   {
     %mip = %blur.getObject(%this.mipsCount + %idx);
     %mip.setShaderConst("$filterRadius", $PostFX::BloomPostFX::radius);
   }
   
   %final = %this->bloomFinal;
   %final.setShaderConst("$strength", $PostFX::BloomPostFX::intensity);
   
   %dirtScale = $PostFX::BloomPostFX::dirtScale;
   %dirtIntensity = $PostFX::BloomPostFX::dirtIntensity;
   %final.setShaderConst("$dirtParams", %dirtScale SPC %dirtScale SPC %dirtIntensity);
   
   %edgeMin = $PostFX::BloomPostFX::dirtEdgeMinDist;
   %edgeMax = $PostFX::BloomPostFX::dirtEdgeMaxDist;
   %edgeVal = $PostFX::BloomPostFX::dirtEdgeMinVal;
   %final.setShaderConst("$edgeParams", %edgeMin SPC %edgeMax SPC %edgeVal);
}

function BloomPostFX::preProcess( %this )
{
  if (%this.dirtEnabled != $PostFX::BloomPostFX::dirtEnabled)
  {
     %this.dirtEnabled = $PostFX::BloomPostFX::dirtEnabled;
     
     %final = %this->bloomFinal;
     if (%this.dirtEnabled)
     {
       %final.setShaderMacro("USE_DIRT");
     } else {
       %final.removeShaderMacro("USE_DIRT");
     }
  }
  
  if(%this.dirtImage !$= $PostFX::BloomPostFX::dirtImage)
  {
    if ($PostFX::BloomPostFX::dirtImage $= "")
      $PostFX::BloomPostFX::dirtImage = "core/postFX/images/lensDirt.png";
    
    %this.dirtImage = $PostFX::BloomPostFX::dirtImage;
    
    %final = %this->bloomFinal;
    %final.setTexture(1, %this.dirtImage);
  }
}

// This function sets up s sort of "mip-chain" for the bloom effect
// Not really "optimal" but it works well enough
function BloomPostFX::SetupBlurFX( %this )
{
   %blurFX = new PostEffect()
   {
     internalName = "bloomBlur";
     allowReflectPass = false;
     shader = Bloom_DownSampleShader;
     stateBlock = Bloom_SampleStateBlock;
     texture[0] = "#threshold";
     target = "#bloom_0";
     targetScale = "0.5 0.5";
     targetFormat = %this.mipTexFormat;
   };
  
   %textureName = "#bloom_0";
   for (%idx = 0; %idx < %this.mipsCount; %idx++)
   {
     %mipName = "bloom_" @ (%idx + 1);
     %mipFX = new PostEffect()
     { 
       internalName = %mipName;
       allowReflectPass = false;
       shader = Bloom_DownSampleShader;
       stateBlock = Bloom_SampleStateBlock;
       texture[0] = %textureName;
       target = "#" @ %mipName;
       targetScale = "0.5 0.5";
       targetFormat = %this.mipTexFormat;
     };
     
     %blurFX.add(%mipFX);
     %textureName = "#" @ %mipName;
   }
   
   for (%idx = %this.mipsCount; %idx > 0; %idx--)
   {
     %nxt = "#bloom_" @ (%idx - 1);
     %mipName = "upSample_" @ (%idx - 1);
     
     %mipFX = new PostEffect()
     {
       internalName = %mipName;
       allowReflectPass = false;
       shader = Bloom_UpSampleShader;
       stateBlock = Bloom_SampleStateBlock;
       texture[0] = %nxt;
       texture[1] = %textureName;
       target = "#" @ %mipName;
       targetScale = "1.0 1.0";
       targetFormat = %this.mipTexFormat;
     };
     
     %blurFX.add(%mipFX);
     %textureName = "#" @ %mipName;
   }
   
   %this.add(%blurFX);
}

function BloomPostFX::onAdd(%this)
{
   %this.SetupBlurFX();
   //Register the postFX with the manager
   PostFXManager.registerPostEffect(%this);
}

function BloomPostFX::onEnabled( %this )
{
   $PostFX::HDRPostFX::enableBloom = 0;
   return true;
}

function BloomPostFX::onDisabled( %this )
{
   return true;
}

//This is used to populate the PostFXEditor's settings so the post FX can be edited
//This is automatically polled for any postFX that has been registered(in our onAdd) and the settings
//are thus exposed for editing
function BloomPostFX::populatePostFXSettings(%this)
{
   PostEffectEditorInspector.startGroup("BloomPostFX - General");
   PostEffectEditorInspector.addCallbackField("$PostFX::BloomPostFX::Enabled", "Enabled", "bool", "", $PostFX::BloomPostFX::Enabled, "", "toggleBloomPostFX");
   PostEffectEditorInspector.addField("$PostFX::BloomPostFX::threshold", "Threshold", "range", "", $PostFX::BloomPostFX::threshold, "0 1 10");
   PostEffectEditorInspector.addField("$PostFX::BloomPostFX::intensity", "Intensity", "range", "", $PostFX::BloomPostFX::intensity, "0 10 10");
   PostEffectEditorInspector.addField("$PostFX::BloomPostFX::radius", "Radius", "float", "", $PostFX::BloomPostFX::radius, "");
   PostEffectEditorInspector.endGroup();
   
   PostEffectEditorInspector.startGroup("BloomPostFX - Lens Dirt");
   PostEffectEditorInspector.addField("$PostFX::BloomPostFX::dirtEnabled", "Enable Dirt", "bool", "", $PostFX::BloomPostFX::dirtEnabled, "");
   PostEffectEditorInspector.addField("$PostFX::BloomPostFX::dirtScale", "Scale", "float", "", $PostFX::BloomPostFX::dirtScale, "");
   PostEffectEditorInspector.addField("$PostFX::BloomPostFX::dirtIntensity", "Intensity", "float", "", $PostFX::BloomPostFX::dirtIntensity, "");
   PostEffectEditorInspector.addField("$PostFX::BloomPostFX::dirtEdgeMinDist", "Min Dist", "range", "", $PostFX::BloomPostFX::dirtEdgeMinDist, "0 1 10");
   PostEffectEditorInspector.addField("$PostFX::BloomPostFX::dirtEdgeMaxDist", "Max Dist", "range", "", $PostFX::BloomPostFX::dirtEdgeMaxDist, "0 1 10");
   PostEffectEditorInspector.addField("$PostFX::BloomPostFX::dirtEdgeMinVal", "Min Value", "range", "", $PostFX::BloomPostFX::dirtEdgeMinVal, "0 1 10");
   PostEffectEditorInspector.addField("$PostFX::BloomPostFX::dirtImage", "Dirt Image", "image", "", $PostFX::BloomPostFX::dirtImage, "");
   PostEffectEditorInspector.endGroup();
}

//This is called back from our callbackField defined in populatePostFXSettings to
//Allow us to easily toggle the postFX and have it respond immediately
function PostEffectEditorInspector::toggleBloomPostFX(%this)
{
   if($PostFX::BloomPostFX::Enabled)
      BloomPostFX.enable();
   else
      BloomPostFX.disable();
}

//This function pair(applyFromPreset and settingsApply) are done the way they are, with the separated variables
//so that we can effectively store the 'settings' away from the live variables that the postFX's actually utilize
//when rendering. This allows us to modify things but still leave room for reverting or temporarily applying them
function BloomPostFX::applyFromPreset(%this)
{
   if($PostFX::BloomPostFX::Enabled)
      %this.enable();
   else
      %this.disable();
}

function BloomPostFX::savePresetSettings(%this)
{
   PostFXManager::savePresetSetting("$PostFX::BloomPostFX::Enabled");
   PostFXManager::savePresetSetting("$PostFX::BloomPostFX::threshold");
   PostFXManager::savePresetSetting("$PostFX::BloomPostFX::intensity");
   PostFXManager::savePresetSetting("$PostFX::BloomPostFX::radius");
   
   PostFXManager::savePresetSetting("$PostFX::BloomPostFX::dirtEnabled");
   PostFXManager::savePresetSetting("$PostFX::BloomPostFX::dirtScale");
   PostFXManager::savePresetSetting("$PostFX::BloomPostFX::dirtIntensity");
   PostFXManager::savePresetSetting("$PostFX::BloomPostFX::dirtImage");
   
   PostFXManager::savePresetSetting("$PostFX::BloomPostFX::dirtEdgeMinDist");
   PostFXManager::savePresetSetting("$PostFX::BloomPostFX::dirtEdgeMaxDist");
   PostFXManager::savePresetSetting("$PostFX::BloomPostFX::dirtEdgeMinVal");
}

//Our actual postFX
singleton PostEffect( BloomPostFX )
{
   mipsCount = 5;
   mipTexFormat = "GFXFormatR16G16B16A16F";
   
   enabled = false;
   allowReflectPass = false;
   
   renderTime = "PFXBeforeBin";
   renderBin = "EditorBin";
   renderPriority = 10000; 
   
   shader = Bloom_ThresholdShader;
   stateBlock = Bloom_SampleStateBlock;
   texture[0] = "$backBuffer";
   target = "#threshold";
   targetFormat = "GFXFormatR16G16B16A16F";
   
   new PostEffect()
   {
    internalName = "bloomFinal";
    allowReflectPass = false;
    shader = Bloom_StrengthShader;
    stateBlock = Bloom_Add_SampleStateBlock;
    texture[0] = "#upSample_0";
    target = "$backBuffer";
   };
};
